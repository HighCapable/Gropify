/*
 * Gropify - A type-safe and modern properties plugin for Gradle.
 * Copyright (C) 2019 HighCapable
 * https://github.com/HighCapable/Gropify
 *
 * Apache License Version 2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is created by fankes on 2025/10/12.
 */
package com.highcapable.gropify.plugin.generator

import com.highcapable.gropify.gradle.api.GradleDescriptor
import com.highcapable.gropify.internal.Logger
import com.highcapable.gropify.internal.error
import com.highcapable.gropify.internal.require
import com.highcapable.gropify.plugin.Gropify
import com.highcapable.gropify.plugin.config.proxy.GropifyConfig
import com.highcapable.gropify.plugin.extension.accessors.proxy.ExtensionAccessors
import com.highcapable.gropify.plugin.generator.extension.PropertyMap
import com.highcapable.gropify.plugin.generator.extension.PropertyTypeValue
import com.highcapable.gropify.plugin.generator.extension.toOptimize
import com.highcapable.gropify.plugin.generator.extension.toPoetNoEscape
import com.highcapable.gropify.utils.extension.capitalize
import com.highcapable.gropify.utils.extension.firstNumberToLetter
import com.highcapable.gropify.utils.extension.uncapitalize
import com.highcapable.gropify.utils.extension.upperCamelcase
import com.highcapable.kavaref.extension.classOf
import com.palantir.javapoet.ClassName
import com.palantir.javapoet.FieldSpec
import com.palantir.javapoet.JavaFile
import com.palantir.javapoet.MethodSpec
import com.palantir.javapoet.TypeSpec
import javax.lang.model.element.Modifier

/**
 * Generator for buildscript accessors classes.
 */
internal class BuildscriptGenerator {

    private companion object {

        private const val ACCESSORS_PACKAGE_NAME = "${Gropify.GROUP_NAME}.plugin.extension.accessors.generated"

        private const val CLASS_SUFFIX_NAME = "Accessors"

        private const val TOP_CLASS_SUFFIX_NAME = "Properties$CLASS_SUFFIX_NAME"
        private const val TOP_SUCCESSIVE_NAME = "_top_successive_name"

        private val NonNullApiClass = ClassName.get("org.gradle.api", "NonNullApi")
        private val NullMarkedClass = ClassName.get("org.jspecify.annotations", "NullMarked")

        private val NonNullClass get() = when {
            // At least Gradle 9.x/10.x, use `@NullMarked` annotation.
            GradleDescriptor.version.let { it.startsWith("9.") || it.startsWith("10.") } -> NullMarkedClass
            // Below Gradle 9.x, use `@NonNullApi` annotation.
            else -> NonNullApiClass
        }
    }

    private val classSpecs = mutableMapOf<String, TypeSpec.Builder>()
    private val constructorSpecs = mutableMapOf<String, MethodSpec.Builder>()
    private val preAddConstructorSpecNames = mutableListOf<Pair<String, String>>()
    private val memoryExtensionClasses = mutableMapOf<String, String>()
    private val grandSuccessiveNames = mutableListOf<String>()
    private val grandSuccessiveDuplicateIndexes = mutableMapOf<String, Int>()
    private val usedSuccessiveMethods = mutableMapOf<String, MutableList<String>>()
    private val usedSuccessiveTags = mutableSetOf<String>()

    private inline fun noRepeated(vararg tags: String, block: () -> Unit) {
        val allTag = tags.joinToString("-")

        if (!usedSuccessiveTags.contains(allTag)) block()
        usedSuccessiveTags.add(allTag)
    }

    private fun String.capitalized() = "${capitalize()}$CLASS_SUFFIX_NAME"
    private fun String.uncapitalized() = "${uncapitalize()}$CLASS_SUFFIX_NAME"

    private fun String.asClassType(packageName: String = "") = ClassName.get(packageName, this)

    private fun TypeSpec.createJavaFile(packageName: String) = JavaFile.builder(packageName, this).build()

    private fun createClassSpec(name: String, accessorsName: String = "", isInner: Boolean = true) =
        TypeSpec.classBuilder(if (isInner) name.capitalized() else name).apply {
            if (isInner) {
                addJavadoc("The \"$accessorsName\" accessors.")

                addSuperinterface(classOf<ExtensionAccessors>())
                addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            } else {
                addJavadoc(
                    """
                      This class is auto generated by Gropify.
                      <br/>
                      You can visit <a href="${Gropify.PROJECT_URL}">here</a> for more help.
                    """.trimIndent()
                )

                addAnnotation(NonNullClass)
                addModifiers(Modifier.PUBLIC)
            }
        }

    private fun createConstructorSpec() = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC)

    private fun TypeSpec.Builder.addSuccessiveField(accessorsName: String, className: String) = addField(
        FieldSpec.builder(className.capitalized().asClassType(), className.uncapitalized(), Modifier.PRIVATE, Modifier.FINAL).apply {
            addJavadoc("Create the \"$accessorsName\" accessors.")
        }.build()
    )

    private fun TypeSpec.Builder.addSuccessiveMethod(accessorsName: String, methodName: String, className: String) =
        addMethod(
            MethodSpec.methodBuilder("get${getOrCreateUsedSuccessiveMethodName(methodName, className).capitalize()}").apply {
                addJavadoc("Resolve the \"$accessorsName\" accessors.")

                addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                returns(className.capitalized().asClassType())
                addStatement("return ${className.uncapitalized()}")
            }.build()
        )

    private fun TypeSpec.Builder.addFinalValueMethod(accessorsName: String, methodName: String, className: String, value: PropertyTypeValue) =
        addMethod(
            MethodSpec.methodBuilder("get${getOrCreateUsedSuccessiveMethodName(methodName, className).capitalize()}").apply {
                val safeValueForJavadoc = value.codeValue.replace("$", "$$")

                addJavadoc("Resolve the \"$accessorsName\" value \"${value.raw.toPoetNoEscape()}\".")

                addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                returns(value.type.java)
                addStatement("return $safeValueForJavadoc")
            }.build()
        )

    private fun MethodSpec.Builder.addSuccessiveStatement(className: String) =
        addStatement("${className.uncapitalized()} = new ${className.capitalized()}()")

    private fun getOrCreateUsedSuccessiveMethodName(methodName: String, className: String): String {
        if (usedSuccessiveMethods[className] == null) usedSuccessiveMethods[className] = mutableListOf()

        val methods = usedSuccessiveMethods[className]!!
        val finalName = if (methods.contains(methodName)) "$methodName${methods.filter { it == methodName }.size + 1}" else methodName
        methods.add(methodName)

        return finalName
    }

    private fun getOrCreateClassSpec(name: String, accessorsName: String = "") =
        classSpecs[name] ?: createClassSpec(name, accessorsName).also { classSpecs[name] = it }

    private fun getOrCreateConstructorSpec(name: String) = constructorSpecs[name]
        ?: createConstructorSpec().also { constructorSpecs[name] = it }

    /**
     * Parse and generate builders for all classes (core function).
     *
     * Before starting the parsing, we need to ensure that [createTopClassSpec]
     * has been called and [clearGeneratedData] has been called once to prevent data confusion.
     *
     * After the parsing is completed, we need to call [releaseParseTypeSpec] to complete the parsing.
     */
    private fun parseTypeSpec(successiveName: String, key: String, value: PropertyTypeValue) {
        fun String.duplicateGrandSuccessiveIndex() = lowercase().let { name ->
            if (grandSuccessiveDuplicateIndexes.contains(name)) {
                grandSuccessiveDuplicateIndexes[name] = (grandSuccessiveDuplicateIndexes[name] ?: 1) + 1
                grandSuccessiveDuplicateIndexes[name] ?: 2
            } else 2.also { grandSuccessiveDuplicateIndexes[name] = it }
        }

        fun String.withoutJavaKeywords() = if (lowercase() == "class") "clazz" else this

        /**
         * Parse (split) names into arrays.
         *
         * Likes "com.foobar" → "ComFoobar" → "foobar".
         */
        fun String.parseSuccessiveNames(): List<Triple<String, String, String>> {
            var grandAccessorsName = ""
            var grandSuccessiveName = ""
            val successiveNames = mutableListOf<Triple<String, String, String>>()

            // Like "com_foobar" or "com__foobar" will be split to ["com", "foobar"].
            val splitNames = split("_").filter { it.isNotBlank() }.ifEmpty { listOf(this) }

            splitNames.forEach { eachName ->
                val name = eachName.capitalize().withoutJavaKeywords().firstNumberToLetter()

                grandAccessorsName += if (grandAccessorsName.isNotBlank()) ".$eachName" else eachName
                grandSuccessiveName += name

                if (grandSuccessiveNames.any { it != grandSuccessiveName && it.lowercase() == grandSuccessiveName.lowercase() })
                    grandSuccessiveName += duplicateGrandSuccessiveIndex().toString()
                grandSuccessiveNames.add(grandSuccessiveName)

                successiveNames.add(Triple(grandAccessorsName, grandSuccessiveName, name))
            }

            return successiveNames.distinct()
        }

        val successiveNames = successiveName.parseSuccessiveNames()
        successiveNames.forEachIndexed { index, (accessorsName, className, methodName) ->
            val nextItem = successiveNames.getOrNull(index + 1)
            val lastItem = successiveNames.getOrNull(successiveNames.lastIndex)

            val nextAccessorsName = nextItem?.first ?: ""
            val nextClassName = nextItem?.second ?: ""
            val nextMethodName = nextItem?.third ?: ""

            val lastClassName = lastItem?.second ?: ""
            val lastMethodName = lastItem?.third ?: ""

            val isPreLastIndex = index == successiveNames.lastIndex - 1

            if (successiveNames.size == 1) getOrCreateClassSpec(TOP_SUCCESSIVE_NAME).apply {
                addFinalValueMethod(key, methodName, className, value)
            }
            if (index == successiveNames.lastIndex) return@forEachIndexed

            if (index == 0) noRepeated(TOP_SUCCESSIVE_NAME, methodName, className) {
                getOrCreateClassSpec(TOP_SUCCESSIVE_NAME, accessorsName).apply {
                    addSuccessiveField(accessorsName, className)
                    addSuccessiveMethod(accessorsName, methodName, className)
                }
                getOrCreateConstructorSpec(TOP_SUCCESSIVE_NAME).addSuccessiveStatement(className)
            }

            noRepeated(className, nextMethodName, nextClassName) {
                getOrCreateClassSpec(className, accessorsName).apply {
                    if (!isPreLastIndex) {
                        addSuccessiveField(nextAccessorsName, nextClassName)
                        addSuccessiveMethod(nextAccessorsName, nextMethodName, nextClassName)
                    } else addFinalValueMethod(key, lastMethodName, lastClassName, value)
                }

                if (!isPreLastIndex) preAddConstructorSpecNames.add(className to nextClassName)
            }
        }
    }

    private fun releaseParseTypeSpec() =
        preAddConstructorSpecNames.onEach { (topClassName, innerClassName) ->
            getOrCreateConstructorSpec(topClassName)?.addSuccessiveStatement(innerClassName)
        }.clear()

    private fun buildTypeSpec(): TypeSpec {
        classSpecs.forEach { (name, typeSpec) ->
            constructorSpecs[name]?.build()?.let { typeSpec.addMethod(it) }
            if (name != TOP_SUCCESSIVE_NAME) classSpecs[TOP_SUCCESSIVE_NAME]?.addType(typeSpec.build())
        }

        return classSpecs[TOP_SUCCESSIVE_NAME]?.build() ?: Gropify.error("Merging accessors class failed.")
    }

    private fun createTopClassSpec(config: GropifyConfig.BuildscriptGenerateConfig) {
        Gropify.require(config.name.isNotBlank()) {
            "Class name cannot be empty or blank."
        }

        val topClassName = "${config.name.replace(":", "_").upperCamelcase()}$TOP_CLASS_SUFFIX_NAME"

        memoryExtensionClasses[config.name] = "$ACCESSORS_PACKAGE_NAME.$topClassName"
        classSpecs[TOP_SUCCESSIVE_NAME] = createClassSpec(topClassName, isInner = false)
        constructorSpecs[TOP_SUCCESSIVE_NAME] = createConstructorSpec()
    }

    private fun clearGeneratedData(clearAll: Boolean = false) {
        classSpecs.clear()
        constructorSpecs.clear()
        preAddConstructorSpecNames.clear()
        grandSuccessiveNames.clear()
        grandSuccessiveDuplicateIndexes.clear()
        usedSuccessiveMethods.clear()
        usedSuccessiveTags.clear()
        if (clearAll) memoryExtensionClasses.clear()
    }

    /**
     * Generate [JavaFile] array.
     *
     * - Note: [allConfig] and [allKeyValues] must be equal in number.
     */
    fun build(
        config: GropifyConfig,
        allConfig: MutableList<GropifyConfig.BuildscriptGenerateConfig>,
        allKeyValues: MutableList<PropertyMap>
    ) = runCatching {
        Gropify.require(allConfig.size == allKeyValues.size) {
            "The number of configurations must be equal to the number of key-value pairs."
        }

        val files = mutableListOf<JavaFile>()
        if (allConfig.isEmpty()) return@runCatching let {
            if (config.debugMode) Logger.get().debug("No buildscript accessors classes to generate.")
            files
        }

        clearGeneratedData(clearAll = true)
        allConfig.forEachIndexed { index, configs ->
            val keyValues = allKeyValues[index]

            clearGeneratedData()
            createTopClassSpec(configs)

            keyValues.toOptimize().forEach { (key, value) ->
                parseTypeSpec(key, value.first, value.second)
                releaseParseTypeSpec()
            }

            files.add(buildTypeSpec().createJavaFile(ACCESSORS_PACKAGE_NAME))
        }

        if (config.debugMode) files.forEach {
            Logger.get().debug(
                "Generated buildscript accessors class: ${it.typeSpec().name()}\n" +
                    "====== BEGIN FILE CONTENT ======\n$it\n====== END FILE CONTENT ======"
            )
        }

        files
    }.getOrElse { Gropify.error("Failed to generated accessors classes.\n${it.stackTraceToString()}") }

    /**
     * Generate compile only stub files for buildscript accessors.
     * @return [List]<[JavaFile]>
     */
    val compileStubFiles get(): List<JavaFile> {
        val stubFiles = mutableListOf<JavaFile>()

        val nonNullFile =
            TypeSpec.annotationBuilder(NonNullClass.simpleName())
                .addModifiers(Modifier.PUBLIC)
                .build().createJavaFile(NonNullClass.packageName())
        val extensionAccessorsFile =
            TypeSpec.interfaceBuilder(classOf<ExtensionAccessors>().simpleName)
                .addModifiers(Modifier.PUBLIC)
                .build().createJavaFile(classOf<ExtensionAccessors>().packageName)

        stubFiles.add(nonNullFile)
        stubFiles.add(extensionAccessorsFile)

        return stubFiles
    }

    /**
     * Get generated buildscript extension class full name by extension name.
     * @param name the extension name.
     * @return [String]
     * @throws IllegalStateException if the class is not found.
     */
    fun propertiesClass(name: String) = memoryExtensionClasses[name] ?: Gropify.error("Could not found class \"$name\".")
}